@can_view
@article.open_access?
@article
@article.class
@article.license_type
@article.poo
exit
sections
section
sections
paid_sections
exit
xml.remove_namespaces!
xml
xml.xpath('//metadata/description')
xml.xpath('//metadata/description').text()
xml.xpath('//metadata/description').html
text_at('//metadata/description')
xml.xpath('//metadata/description')
xml.xpath('//metadata/description')exit
xml
rspec
exit
page
page.inspec
page.inspect
page.html
json_page
json
json_response
json_response.has_text? 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(json_response).to have_text 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(json_response).to contain 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(json_response).to have_text 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(page).to have_text 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(page).to have_text 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive them.'
exit
json_response
exit
article.sections
subject.sections
subject.real_raw_hash['sections']
exit
real_raw_hash
real_raw_hash['sections']
exit
real_raw_hash
real_raw_hash['sections']
exit
real_raw_hasj
real_raw_hash
real_raw_hash['sections']
clipit real_raw_hash['sections']
install-command clipit
clipit real_raw_hash['sections']
exit
clipit real_raw_hash['sections']
install-command clipit
gist --clip real_raw_hash['sections']
install-command gist
install-command clipit
install-command clipit!
real_raw_hash['sections']
Pry.config.pager = false
real_raw_hash['sections']
{"html"=>
  "<p>Here we attempt to use natural polymers as the ligands to replace the synthetic counterparts
 {"title"=>"Results",
"title_no_links"=>"Results",
"id"=>"results",
"items"=>
[{"paragraph"=>
    {"html"=>
      "<p>A series of homogeneous BWT-Pd<sup>2+</sup> complex catalysts were prepared by simply mixing
    {"figure"=>
      {"id"=>"f1",
"num"=>"1",
"link"=>"/articles/nmstr201553/figures/1",
"title_html"=>
"Schematic illustration of preparation of polyphenols-chelated metal catalysts.",
"title"=>
"Schematic illustration of preparation of polyphenols-chelated metal catalysts.",
"html"=>"",
"main_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/images",
"filename"=>"nmstr201553-f1.jpg"}],
"carousel_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/carousel",
"filename"=>"nmstr201553-f1.jpg"}],
"page_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/images_article",
"filename"=>"nmstr201553-f1.jpg"}],
"list_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/thumbs_article",
"filename"=>"nmstr201553-f1.jpg"}],
"hires_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/images_hires",
"filename"=>"nmstr201553-f1.jpg"}],
"next_figure"=>
{"title"=>"Hydrogenation of cinnamalydehyde.",
  "link"=>"/articles/nmstr201553/figures/2",
"num"=>"2"}}},
{"paragraph"=>
  {"html"=>
    "<p>Hydrogenation of cinnamaldehyde is employed as the probe reaction to evaluate the catalytic 
    {"figure"=>
      {"id"=>"f2",
"num"=>"2",
"link"=>"/articles/nmstr201553/figures/2",
"title_html"=>"Hydrogenation of cinnamalydehyde.",
"title"=>"Hydrogenation of cinnamalydehyde.",
"html"=>"",
"main_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/images",
"filename"=>"nmstr201553-f2.jpg"}],
"carousel_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/carousel",
Pry.config.pager = false
real_raw_hash['sections']
exit
real_raw_hash
exit
real_raw_hash
exit
[1, 2, 3] + [4, 5, 6]
%w( some thing ) + %w( else trololol )
exit
can_view?
free_sections
sections = filter_sections(free_sections)
real_raw_hash['sections']
exit
real_raw_hash
exi
exit
sections
sections[0]
sections[1]
article.pseudo_abstract_section
exit
page
json_response
page.text
exit
EXIT
exit
json_response['article']['sections']
json_response['article']['sections'][0]['pseudo_abstract] == true
json_response['article']['sections']
article
page
page.article
json_respinse['article']
json_respinse['article']exit
exit
json_response['article']
json_response['article']['sections']
json_response
exit
json_response['article']['sections']
json_response['article']['sections'].find { |section| section['pseudo_abstract'] == true }
nil.present?
json_response['article']['sections'][0]['pseudo_abstract']
exit
sections
sections[:subscribe_propt_section
]
sections.index { |s| puts s }
sections.index { |s| s.subscribe_prompt_section }
sections.index { |s| s['subscribe_prompt_section'].true? }
sections.index { |s| s.has_key?('subscribe_prompt_section') }
sections.index { |s| s.each.has_key?('subscribe_prompt_section') }
sections.index { |s| s.each{ |x| x.has_key?('subscribe_prompt_section') } }
sections.index { |s| s.map{ |x| x.has_key?('subscribe_prompt_section') } }
sections.index { |s| s.inspect }
sections.inspect
sections[0
]
sections[1]
sections[2]
sections[2].has_key?('subscribe_prompt_section')
sections[2][:subscribe_prompt_section]
sections[1][:subscribe_prompt_section]
sections[2][:subscribe_prompt_section]
sections.map{ |s| s[:subscribe_prompt_section] }.present?
sections.class
sections.map
sections.index{ |s| s.inspect }
sections.index{ |s| puts s }
sections.index{ |s| s[] }
sections.index{ |s| s[0] }
sections.index{ |s| puts s[0] }
sections.index{ |s| puts s.class; nil  }
sections.index{ |s| puts s.class; s.inspect; puts '========'; nil  }
sections.index{ |s| puts s.class; s; puts '========'; nil  }
sections.index{ |s| puts s.class; puts s.inspect; puts '========'; nil  }
sections.index{ |s| s[:subscribe_prompt_section] if s.class == Hash }
sections.index{ |s| s[:subscribe_prompt_section] if s.class == Hash }sections = [{:a => true}, {:b false}]
sections = [{:a => true}, {:b false}]
sections = [{:a => true}, {:b => false}]
sections.index{ |s| s[:subscribe_prompt_section] if s.class == Hash }
exit
json_response['article']['sections']
json_response['article']['sections'][0]
json_response['article']['sections'][0][1]
json_response['article']['sections'][3]
json_response['article']['sections'][2]
json_response['article']['sections'][2]["subscribe_prompt_section"]
json_response['article']['sections'][2]["subscribe_prompt_section"] == true
exit
puts section
puts section.class
puts sectionsection['subscribe_prompt_section'].present?
puts section['subscribe_prompt_section'].present?
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
puts section
puts section.class
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
section
exit
section
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
[{:a => true}, {:b => false}] + {:c => true} + {:d => false} + [{:e => true}, {:f => false}]
[{:a => true}, {:b => false}] + [{:c => true}] + [{:d => false}] + [{:e => true}, {:f => false}]
request
request.env
exit
subject
subject.inspect
subject.build_log_row
subject.response
subject
subject.response
exit
subject.response
subject
exit
subject.response
subject.response['REQUEST_URL']
subject.response['REQUEST_URI']
subject.responseexit
exit
subject.build_log_row
exit
Time.zone.now
/Users/matt.rayner/laserwolf Time.now
Time.zone
Time.now
Time.now.utc
Time.now
Time.now.utc
exit
page
page.html
exit
page.html
exit
page.html
exit
bands[hub_article_type]
exit
exit!
hub_article_type
hub_article_type.id
exit
band
type
exit
band
hub_article_type
hub_article_type.id
exit
type
exit
type
band
exit
current_user
current_user.nature_id
exit
exit!
page.html
page.text
page.json
page.
page.html
expect(page).to have_text('$18')
expect(page).to have_text('$32')
page.reload
exit
hub_article_type.inspect
exit
hub_primary_article_type
hub_primary_article_type.id
exit
exit!
@product.pcode
exit
params['hasPrimaryArticleType']
exit
params['hasPrimaryArticleType']
exit
params['hasPrimaryArticleType']
exit
params['hasPrimaryArticleType']
exit
json_response['results']
json_response['results'].first
json_response['results'].first['primary_article_type']['prefLabel']
expect(research_types).to include(json_response['results'].first['primary_article_type']['prefLabel'])
exit
Issue.new
exit
Issue.new
Issue.new(site_id: 4, volume: 1, issue: 25)
exit
@issue
@site
exit
issue
@issue
@site
exit
foo
exit
foo
@site
@issue
exit
@issue
@
@sire
@site
@issue
i = Issue.new(site_id: @site.id, volume: 1, issue: 25)
i.save
i.save!
i = Issue.new(hub_id: 'nqdkpw', site_id: @site.id, volume: 1, issue: 10)
i.save!
exit
@issue.published?
exit
page.status_code
@issue.published?
exit
@serialize
@serialized
exit
@serialized
exit
@serialized[:toc_sections].last[:articles]
exit
@section[:articles]
exit
arts.inspect
exit
xml
exit
xml
exit
xml
next
article
next
article.doi
exit
next
article.xml.xpath('//front//article-id[@pub-id-type="doi"]')
article.xml
Nokogiri.parse(article.xml).xpath('//front//article-id[@pub-id-type="doi"]')
Nokogiri.parse(article.xml).xpath('//front//article-id[@pub-id-type="doi"]').text
exit!
exit
next
article.doi
exit
next
article.doi
next
article.doi
article.class
exit!
exit
exit!
article.doi
articles
id
article.id
article.article_id
exit
article.article_id
exit
article.article_id
exit
article.article_id
exit
exit!
article
exit
@articles
@articles[:articles]
@articles[:articles][0]
@articles[:articles][0].inspect
@articles[:articles][0].publication_date
@articles[:articles][0].publication_date.utc
Time.parse(@articles[:articles][0].publication_date.to_s).utc
exit
exit!
opts
opts[:feature_flags]
opts[:feature_flags].fetch('fetch-articles-from-hub', false)
exit
FeatureFlagsSerializer.new({
    feature_flags: @opts[:feature_flags]
}),
})
FeatureFlagsSerializer.new(@opts)
FeatureFlagsSerializer.new(@opts).serialize
exit
visit '/maestrorj/ealert?end_date=20150130&days=30&proof=true'
product_family
Settings
Settings["Product_families"]
Settings["product_families"]
family_code
exit
@domain
product_family['domain'] = "nature.com"
product_family = []
product_family['domain'] = "nature.com"
product_family = {}
product_family['domain'] = "nature.com"
@domain
exit
@serializer
@serializer[:articles]
@serializer[:articles][:research]
@serializer[:articles][:research].first
require 'mosaic'
require mosaic
require <osaic
require Mosaic
require 'mosaic-containers'
exot
exit
require 'mosaic-containers'
exit
require 'mosaic-containers'
exit
require 'mosaic-containers'
exit
require 'mosaic-containers'
require 'mosaic'
require 'mosaic-containers'
require 'mosaic'
Mosaic::Containers::Home.new
Mosaic::Containers::Hello.new
require 'mosaic'
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
Mosaic::Containers
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
require Mosaic
require 'mosaic'
Mosaic::Containers::Hello.new
include Mosaic
exit
include Mosaic
Mosaic::Containers::Hello.new
include Mosaic
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
exit
Mosaic::Containers::Hello.new
a = Mosaic::Containers::Hello.new
a = Mosaic::Containers::Hello
a = Mosaic::Containers::Hello.reload!
a = Mosaic::Containers::Hello.new
a = Mosaic::Containers::Hello.reload!
a = Mosaic::Containers::Hello.new
reload
exit
a = Mosaic::Containers::Hello.new
bundle
exit
EXIT
exit
a = Mosaic::Containers::Hello.new
exit
exi
exit
articles
articles.value
temp
temp2
exit
articles
articles.first
articles.first.inspect
articles.first.id
articles.first.doi
articles.first.article_type
articles.first.title
articles.first.title_html
articles.first.published_on
articles.first.published
articles.first.published_at
articles.first.published_on
articles.first.published_at?
articles.first.published?
articles.first.published_at
articles.first.published_on
articles.first.published_label
articles.first.epub_year
articles.first.publication_year
articles.first.volume
articles.first.number
articles.first.fpage
page_start
articles.first.page_start
exit
celluloid
celluloid.value
celluloid.value.valueexit
exit
exit!
celluloid
celluloid.value
exit!
celluloid.value
celluloid
exit!
celluloid
celluloid.value
celluloid.value.value
celluloid.value.value[articles
  celluloid.value.value[:articles]
celluloid.value.value
celluloid.value.value[:atricles]
celluloid.value.value[:articles]
celluloid.value.value[:articles].first
exit
exit!
articles.value.value[:articles].first
temp
temp.pref_label
temp.primary_article_type
temp.article_type
temp.type
temp.first.primary_article_type
temp.first.article_type
expected_attributes
expected_attributes.each do |attr|
  puts attr
  expect(article_json[attr.to_sym]).not_to be_nil
end
exit
subject[:articles].first.as_json
subject[:articles].first.as_json[:id
  q
exit
subject[:articles].first.as_json[:id]
subject[:articles].first.as_json[id]
subject[:articles].first.as_json['id']
subject[:articles].first[:id]
exit
article_json
article_json[:id]
exit
articles
exit
@articles.first.primary_article_type
@articles.first
@articles.first.inspect
@articles.first.as_json
exit
@aricles.first.primary_article_tpye
@aricles.first.primary_article_type
@articles
@articles.first
@articles.first.primary_article_type
@articles.first.primary_article_type.pref_label
exit
exit
exit!
single_item
exit!
single_tem
single_item
exit
@article
exit
@article
@article.inspect
@article.di
@article.id
exit
@article
@article.id
exit
@serializer[:articles]
@serializer[:articles][:research].first
exit
@articles
@articles.first
@articles[:research]
@articles
@articles.research
@articles.research.first
@articles.research.first[:contributors]
@articles.research.first[:contributors].first
@articles.research.first[:contributors].first.as_json
exot
exit
subject[:articles]
subject[:articles][:research]
subject[:articles][:research].firsy
subject[:articles][:research].first
exit
subject
exit
subject
exit
subject
exit
value
exit
contributors
@serializer[:articles]
exit
@serializer[:articles][:research]
@serializer[:articles][:research].first
@serializer[:articles][:research].first.contributors
@serializer[:articles][:research].first
exit
subject[:articles][:research].first
subject[:articles][:research].first[:path]
exit
subject[:articles][:research].first[:path]
subject[:articles][:research].first
exit
subject[:articles][:research].first
exi\
exit
subject[:articles]
subject[:articles][:correctiosn]
subject[:articles]
exit
article
exit
article
article.publication_date
article.publication_date.utc
article.publication_date.to_s
exit
exit!
@articles
exit
exit!
articles
exit
@article
@article.as_json
@article[:contributors]
exit
subject
article_json
@article_json
exit
@article_json
subject[:articles]
subject[:articles].first
subject[:articles].first.as_json
subject[:articles].first.to_s
subject[:articles].first.to_json
exit
article_json
exit
article_json
article_json[:number]
article_json[
]
exit
article_json
article_json.id
article_json.[id]
article_json.id
exit
article_json
article_json.id
article_json[:doi
]
article_json[:doi]
exit
article_json
exit
article_json
exit
article
article.id
exit
req.uri
exit
exit!
Product.find_by(pcode: pcode)
Product.make!(pcode: pcode, ptype: ptype ? ptype.strip : 'journal')
family_code
step %Q{the product "#{pcode}", with the name "#{name}" has been setup in PSET}
step
exit!
site
SiteManager.activate(site)
exit
facets
results
exit
exit!
facets
exit
params
exit
exit!
params
exit
articles
exit
temp
temp[:articles].first.title
temp[:articles].first[:title]
temp[:articles].first.title
temp[:articles][1].title
temp[:articles][2].title
temp[:articles].map { |a| a.title }
exit!
hub_issue
exit!
json_response
json_response[:containers]
json_response['containers'].select { |container| container['type'] == 'current-issue' }
exit!
containers
exit!
current_issue
current_issue.cover_image
current_issue.cover_image.url
exit
results
results.value
temp
temp[:facets]:publication_year_month]
temp[:facets][:publication_year_month]
temp[:facets][:publication_year_month].first
temp[:facets][:publication_year_month].first.value
temp[:facets][:publication_year_month].first.total
temp[:facets][:publication_year_month].first.inspect
temp[:facets][:publication_year_month].first.methods
temp[:facets][:publication_year_month].first.as_json
first = temp[:facets][:publication_year_month].first
first_date = Date.parse(first.value)
first_date = Date(first.value)
Date.parse
Date.parse(item.value)
Date.parse(item.text)
first.value
DateTime.parse(first.value)
Date.parse(first.value)
Date.strfmtime(first.value)
Date.strptime(first.value, '%Y-%m')
Date.strptime(first.value, '%Y-%m').month
exit
results
results.each { |r| r.value }
results.each { |r| puts(r.value) }
exit
get_query_options
exit
articles
exit
get_query_options
exit
get_query_options
exit
get_query_options
exit
params['facets']
exit!
prams['facet']
params['facet']
exit
params['facet'
]
params['facet']
params['include']
params
exit
exit!
prams
params
exit
params
exit
params
exit!
params
exit
params
exit
params
exit
params
exit
params
exit
prams
params
exit!
@articles_requests.is_a?(Array)
temp_articles = []
@articles_requests.each { |article| temp_articles << Macmillan::Service::Helper.http_request_result(article, fallback: {})[:articles] }
temp_articles
exit
page_content
page_content.fa_dois
requests
exit
@articles
@articles_requests
temp_articles
article
exit!
rewuests
requests
exit
temp
exit!
exit
temp
exit
temp
exit
temp
exit
string = 'Hello World'
*string
foo = *string
array = ['Hello', 'World']
bar = *array
[].respond_to?(:flat_map)
exit
article_request
articles_request
exit
title = "A title"
title.parameterize
title = nil
title.parameterize
nil.parameterize
nil.to_s.parameterize
exit
container
containers
exit
page_content
page_content.top_item_image
exit
exit!
exit!
@title
exit!
exit
hub_issue
hub_issue.id
Issue.find(hub_id: 'qbvjsz')
Issue.find_by(hub_id: 'qbvjsz')
Issue.all
exit
exit!
exut
ext
exit
Issue.all
hub_issue
exit
hub_issue
exit
section
section.hub_section
section.hub_section.title
section.hub_section.articles
exit
section.hub_section.articles
exit
admin
Devise::TestHelpers
include Devise::TestHelpers
exit
sign_in
Devise::TeashHelpers
Devise::TestHelpers
Devise::TestHelpers.sign_in
Devise::TestHelpers.methods
exit
sign_in 
sign_in user
admin
let(:admin) { Admin.new }
let(:admin) { double(Admin) }
exit
build(:admin)
FactoryGirl.build(:admin)
exit
build(:admin)
exit
project
exit!
view
rendered
view.partials
exit
projects_array
exit
rendered
exit
hash = { a: '1', b: '2', c: '3', d: '4' }
hash.slice(:a, :e)
exit
opts
exit
step
next
exit
controller
controller_name
exit
controller
render_mode.staging_content? || TEST_ENVIRONMENT
controller,
q
controller
site
page
@Issue
@issue
exit
issue
exit
product
issue
issue.site
exit
issue.site
issue.site.id
exit
issue.site)id
issue.site_id
issue.site
journal
journal.id
journal.id.active
exit
IssueService.new
issue_service.current_issue(augmented: false)
issue = issue_service.current_issue(augmented: false)
issue
if issue
  puts 'true'
else
  puts 'false
end
product.pcode
get :current, pcode: product.pcode
issue = issue_service.current_issue(augmented: false)
issue.truthy?
issue?
@page
exit
exit
params
params[:project][
]
params[:project]
params[:project][:gallery_images]
params[:project][:gallery_images][0]
params[:project][:gallery_images]
params[:project][:gallery_images][0]wx
exit
p
p.object
exit
exit!
project_params
exit
project_params
params[:project][:gallery_image_attributes].first
params[:project][:gallery_image_attributes]
params[:project]
params[:project][:gallery_imagew_attributes]
params[:project][:gallery_images_attributes]
params[:project][:gallery_images_attributes].first
params[:project][:gallery_images_attributes].first[1].remove_image
params[:project][:gallery_images_attributes].first[1][:remove_image]
params[:project][:gallery_images_attributes].first[1][:id]
exit
params
exit
exit!
flash
flash[:alert]
flash[:notice]
response
response.code
exit
params
exit
article_access
can_view?
exit
access
article_access
exit
case_study
@case_study
case_study
exit
activities[:summary]
activities['summary']
activities['summary']['steps']
activities['summary']['steps']exit
exit
@sidebar_configuration
exit
instance_stats
stats
controller.instace_variable_get(:£fit_bit_stats)
controller.instace_variable_get(:@fit_bit_stats)
controller.instance_variable_get(:@fit_bit_stats)
controller.instance_variable_get(:@fit_bit_statsçexit
exit
FitBitStats.last
FitBitStats
.all
FitBitStats.all
create(:fit_bit_stats)
FitBitStats.all
exit
controller
exir
exit
@user_site_ids
@user_site_ids.inspect
@user_site_ids.methofs
@user_site_ids.methods
@user_site_ids.to_s
''.blank?
exit
crumb
exit
crumb
crumb[:title]
root
child_crumb
exit
crumbs
exit
crumbs
[{ title: 'Matt Rayner', url: root_path }] + crumbs
exit
crumbs
exit
crumbs
crumb
cumbs.empty?
crumbs.empty?
exit
crumb
crumbs
exit
crumbs
crumb
exit
crumb
crumbs
exit
exit!
crumb
crumbs
exit
crumb
crumbs
exit
crumb
crumbs
exit
crumb
crumbs
exit
crumb
xrumbs
crumbs
exit
exit!
article
article.raw_hash
article.raw_hash.reject { |k,v| ARTICLE_REMOVED_FIELDS.includes?(k)  }
article.raw_hash.reject { |k,v| ARTICLE_REMOVED_FIELDS.include?(k)  }
article.raw_hash
article.raw_hash.reject { |k,v| ARTICLE_REMOVED_FIELDS.include?(k) }
article.raw_hash.reject { |k,v| ARTICLE_REMOVED_FIELDS.include?(k) }.merge(message_attributes)
exit
exit!
settings
settings.inspect
settings.inspect['submit_manustript']
exit
site
sidebar_settings(site)
sidebar_settings(site).methods
sidebar_settings(site).data
sidebar_settings(site)
exit
