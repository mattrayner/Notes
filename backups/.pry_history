@can_view
@article.open_access?
@article
@article.class
@article.license_type
@article.poo
exit
sections
section
sections
paid_sections
exit
xml.remove_namespaces!
xml
xml.xpath('//metadata/description')
xml.xpath('//metadata/description').text()
xml.xpath('//metadata/description').html
text_at('//metadata/description')
xml.xpath('//metadata/description')
xml.xpath('//metadata/description')exit
xml
rspec
exit
page
page.inspec
page.inspect
page.html
json_page
json
json_response
json_response.has_text? 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(json_response).to have_text 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(json_response).to contain 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(json_response).to have_text 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(page).to have_text 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive'
expect(page).to have_text 'Descriptions of new technologies, including geoengineering, can influence the way the public perceive them.'
exit
json_response
exit
article.sections
subject.sections
subject.real_raw_hash['sections']
exit
real_raw_hash
real_raw_hash['sections']
exit
real_raw_hash
real_raw_hash['sections']
exit
real_raw_hasj
real_raw_hash
real_raw_hash['sections']
clipit real_raw_hash['sections']
install-command clipit
clipit real_raw_hash['sections']
exit
clipit real_raw_hash['sections']
install-command clipit
gist --clip real_raw_hash['sections']
install-command gist
install-command clipit
install-command clipit!
real_raw_hash['sections']
Pry.config.pager = false
real_raw_hash['sections']
{"html"=>
  "<p>Here we attempt to use natural polymers as the ligands to replace the synthetic counterparts
 {"title"=>"Results",
"title_no_links"=>"Results",
"id"=>"results",
"items"=>
[{"paragraph"=>
    {"html"=>
      "<p>A series of homogeneous BWT-Pd<sup>2+</sup> complex catalysts were prepared by simply mixing
    {"figure"=>
      {"id"=>"f1",
"num"=>"1",
"link"=>"/articles/nmstr201553/figures/1",
"title_html"=>
"Schematic illustration of preparation of polyphenols-chelated metal catalysts.",
"title"=>
"Schematic illustration of preparation of polyphenols-chelated metal catalysts.",
"html"=>"",
"main_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/images",
"filename"=>"nmstr201553-f1.jpg"}],
"carousel_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/carousel",
"filename"=>"nmstr201553-f1.jpg"}],
"page_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/images_article",
"filename"=>"nmstr201553-f1.jpg"}],
"list_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/thumbs_article",
"filename"=>"nmstr201553-f1.jpg"}],
"hires_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/images_hires",
"filename"=>"nmstr201553-f1.jpg"}],
"next_figure"=>
{"title"=>"Hydrogenation of cinnamalydehyde.",
  "link"=>"/articles/nmstr201553/figures/2",
"num"=>"2"}}},
{"paragraph"=>
  {"html"=>
    "<p>Hydrogenation of cinnamaldehyde is employed as the probe reaction to evaluate the catalytic 
    {"figure"=>
      {"id"=>"f2",
"num"=>"2",
"link"=>"/articles/nmstr201553/figures/2",
"title_html"=>"Hydrogenation of cinnamalydehyde.",
"title"=>"Hydrogenation of cinnamalydehyde.",
"html"=>"",
"main_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/images",
"filename"=>"nmstr201553-f2.jpg"}],
"carousel_image_paths"=>
[{"root"=>"/nmstr/2015/nmstr201553/carousel",
Pry.config.pager = false
real_raw_hash['sections']
exit
real_raw_hash
exit
real_raw_hash
exit
[1, 2, 3] + [4, 5, 6]
%w( some thing ) + %w( else trololol )
exit
can_view?
free_sections
sections = filter_sections(free_sections)
real_raw_hash['sections']
exit
real_raw_hash
exi
exit
sections
sections[0]
sections[1]
article.pseudo_abstract_section
exit
page
json_response
page.text
exit
EXIT
exit
json_response['article']['sections']
json_response['article']['sections'][0]['pseudo_abstract] == true
json_response['article']['sections']
article
page
page.article
json_respinse['article']
json_respinse['article']exit
exit
json_response['article']
json_response['article']['sections']
json_response
exit
json_response['article']['sections']
json_response['article']['sections'].find { |section| section['pseudo_abstract'] == true }
nil.present?
json_response['article']['sections'][0]['pseudo_abstract']
exit
sections
sections[:subscribe_propt_section
]
sections.index { |s| puts s }
sections.index { |s| s.subscribe_prompt_section }
sections.index { |s| s['subscribe_prompt_section'].true? }
sections.index { |s| s.has_key?('subscribe_prompt_section') }
sections.index { |s| s.each.has_key?('subscribe_prompt_section') }
sections.index { |s| s.each{ |x| x.has_key?('subscribe_prompt_section') } }
sections.index { |s| s.map{ |x| x.has_key?('subscribe_prompt_section') } }
sections.index { |s| s.inspect }
sections.inspect
sections[0
]
sections[1]
sections[2]
sections[2].has_key?('subscribe_prompt_section')
sections[2][:subscribe_prompt_section]
sections[1][:subscribe_prompt_section]
sections[2][:subscribe_prompt_section]
sections.map{ |s| s[:subscribe_prompt_section] }.present?
sections.class
sections.map
sections.index{ |s| s.inspect }
sections.index{ |s| puts s }
sections.index{ |s| s[] }
sections.index{ |s| s[0] }
sections.index{ |s| puts s[0] }
sections.index{ |s| puts s.class; nil  }
sections.index{ |s| puts s.class; s.inspect; puts '========'; nil  }
sections.index{ |s| puts s.class; s; puts '========'; nil  }
sections.index{ |s| puts s.class; puts s.inspect; puts '========'; nil  }
sections.index{ |s| s[:subscribe_prompt_section] if s.class == Hash }
sections.index{ |s| s[:subscribe_prompt_section] if s.class == Hash }sections = [{:a => true}, {:b false}]
sections = [{:a => true}, {:b false}]
sections = [{:a => true}, {:b => false}]
sections.index{ |s| s[:subscribe_prompt_section] if s.class == Hash }
exit
json_response['article']['sections']
json_response['article']['sections'][0]
json_response['article']['sections'][0][1]
json_response['article']['sections'][3]
json_response['article']['sections'][2]
json_response['article']['sections'][2]["subscribe_prompt_section"]
json_response['article']['sections'][2]["subscribe_prompt_section"] == true
exit
puts section
puts section.class
puts sectionsection['subscribe_prompt_section'].present?
puts section['subscribe_prompt_section'].present?
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
puts section
puts section.class
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
section
exit
section
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
puts section[0]['subscribe_prompt_section'].present?
exit
[{:a => true}, {:b => false}] + {:c => true} + {:d => false} + [{:e => true}, {:f => false}]
[{:a => true}, {:b => false}] + [{:c => true}] + [{:d => false}] + [{:e => true}, {:f => false}]
request
request.env
exit
subject
subject.inspect
subject.build_log_row
subject.response
subject
subject.response
exit
subject.response
subject
exit
subject.response
subject.response['REQUEST_URL']
subject.response['REQUEST_URI']
subject.responseexit
exit
subject.build_log_row
exit
Time.zone.now
/Users/matt.rayner/laserwolf Time.now
Time.zone
Time.now
Time.now.utc
Time.now
Time.now.utc
exit
